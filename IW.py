import subprocess
import re, io, os, sys
import pylab
import argparse
import math
from Bio import Phylo
from Bio.Phylo.Consensus import majority_consensus


def validate_arguments(parser, args):
    """
    Checks additional parameter requirements that are hard to pass by argparser.
    """

    def error(message):
        parser.print_usage()
        sys.stderr.write("error: " + message)
        sys.exit(1)

    if args.kmin <= 0:
        error("argument kmin: invalid choice: can't be less than 1")
    if args.kmin > args.kmax:
        error("arguments kmin and kmax: invalid choice: minimal value can't be greater that maximum")
    if args.kmax > 1000:
        error("argument kmax: maximum k value can't be greater than 1000")


def reformat_tree(tree: str) -> str:
    """
    Reformat tree from TnT output format (Newick without commas) to normal Newick.
    Replace dots from taxon names to underscores (Phylo requirement).
    """
    tree = tree.replace(".", "_")
    tree = re.sub(r"([\w|\d])\s([\w|(])", r"\1, \2", tree)
    tree = re.sub(r"\)\(", r"), (", tree)
    return tree


def log_space(k_min: int, k_max: int, num_of_steps=None) -> list:
    """
    Creates a list of k values with logarithmic step.
    Takes minimum k value, maximum k value and number of steps.
    If number of steps is not given it is calculated based on k values, but not less then 10.
    """
    num_of_steps = max(int(((k_max - k_min) / 10) * 3), 10) if not num_of_steps else num_of_steps
    lin_steps = [math.log(k_min) + x * (math.log(k_max) - math.log(k_min)) / (num_of_steps - 1)
                 for x in range(num_of_steps)]
    return sorted(list(set([int(round(i)) for i in
                            [math.exp(num) for num in lin_steps]
                            ])))


def parse_tnt_trees(k_values: list) -> list:
    """
    Return list with trees generated by TnT for selected k values.
    """
    list_of_trees = []
    for i in k_values:
        with open(f"k{i}.tre") as f:
            list_of_trees.append([Phylo.read(io.StringIO(reformat_tree(line.strip().strip(";"))), "newick")
                                  for line in f.readlines()[1:-1]][-1])
    return list_of_trees


def parse_args():
    parser = argparse.ArgumentParser(
        description="Branch support method based on maximum parsimony tree and implemented weighting with"
                    "different k-valuesx.")
    parser.add_argument("-i", "--input", help="Input file.", metavar="File", required=True)
    parser.add_argument("-o", "--output", help="Output file.", metavar="File", required=True)
    parser.add_argument("kmin", action="store", type=int, help="Minimal value of k parameter.")
    parser.add_argument("kmax", action="store", type=int, help="Maximum value of k parameter.")
    parser.add_argument("--N", help="Determine number of k-values. Default value is calculated based"
                                    "on minimum and maximum k values.")
    parser.add_argument("-f", "--fasta", help="Handle input as fasta file.",
                        action="store_true", default=False)
    parser.add_argument("-t", "--tnt", help="Path to a command-line TnT executable file.",
                        action="store", default="tnt")
    parser.add_argument("--format", help="Determine tree output format. "
                                         "Default: newick.",
                        action="store", default="newick", type=str.lower,
                        choices=["newick", "nexus", "phyloxml", "nexml", "cdao"])
    parser.add_argument("-c", "--clean", help="Delete intermediate files (TnT trees for different k values).",
                        action="store_true", default=False)
    parser.add_argument("-d", "--draw", help="Draw final tree (creates a png file).",
                        action="store_true", default=False)
    args = parser.parse_args()
    return parser, args


def run_tnt_script(args):
    if args.fasta:
        p = subprocess.Popen(f"{args.tnt} proc &{args.input} run iw_branch_support.run {args.kmin} {args.kmax};")
    else:
        p = subprocess.Popen(f"{args.tnt} proc {args.input} run iw_branch_support.run {args.kmin} {args.kmax};")
    p.wait()


def delete_files(clean, kmin, kmax, k_values):
    """
    Deletes unnecessary trees.
    This needs to be redone with proper tnt argument handling.
    """
    for i in range(kmin, kmax):
        if clean or i not in k_values:
            os.remove(f"k{i}.tre")


def draw(tree):
    fig = pylab.figure(figsize=(10, 20), dpi=100)
    axes = fig.add_subplot(1, 1, 1)
    Phylo.draw(tree, do_show=False, axes=axes)
    pylab.savefig(f"consensus_tree.png", bbox_inches=None, figsize=(20, 20), dpi=100)


def delete_branch_length(args):
    """
    Deletes branch length from file cause majority consensus can't be done without length.
    """
    with open(args.output, "r") as result_file:
        result_tree = result_file.readlines()
    with open(args.output, "w") as result_file:
        for line in result_tree:
            result_file.write(re.sub(r":[0-9.]+", "", line))


def run():
    parser, args = parse_args()
    validate_arguments(parser, args)
    run_tnt_script(args)
    k_values = log_space(args.kmin, args.kmax, args.N)
    trees = parse_tnt_trees(k_values)
    consensus_tree = majority_consensus([tree for tree in trees], 0)
    with open(args.output, "w") as result_file:
        Phylo.write(consensus_tree, result_file, args.format)
    if consensus_tree.total_branch_length() == 0:
        delete_branch_length(args)
    if args.draw:
        draw(consensus_tree)
    delete_files(args.clean, args.kmin, args.kmax, k_values)


if __name__ == "__main__":
    run()
